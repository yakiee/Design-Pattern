## C# 中的析构函数（Finalizer）

​	析构函数是 C# 中的一种特殊方法，用于在对象被垃圾回收之前执行清理操作。以下是关于析构函数的一些关键点：

### 1. 定义

- **名称**：析构函数的名称与类名相同，并以波浪号（`~`）开头。
- **特性**：没有参数，也没有返回值。

### 2. 自动调用

​	当对象不再被引用并即将被垃圾回收时，垃圾回收器会自动调用析构函数。开发者不需要手动调用析构函数。

#### **2.1 对象实例化**

​	使用 `new` 关键字创建对象时，构造函数被调用。析构函数并不在这个阶段执行。

#### **2.2 对象的使用**

​	在对象的生命周期内，可以调用对象的方法和访问属性。当不再需要这个对象时，可以将其引用置为 `null`，但这并不会立即销毁对象。

#### **2.3 垃圾回收**

​	当对象不再被任何引用指向时，垃圾回收器会在适当的时候自动将其标记为可回收。如果对象有定义析构函数，垃圾回收器会在回收之前调用它。

##### **2.3.1 引用置为 null**

- 将对象的引用置为 `null` 会减少引用计数。如果没有其他引用指向该对象，垃圾回收器会将其标记为可回收。
- 这并不会立即销毁对象，而是将其状态标记为可回收，实际销毁发生在垃圾回收器运行时。

##### **2.3.2 垃圾回收的触发**

- 垃圾回收器在内存使用达到一定阈值时自动触发，扫描托管堆中的对象，查找没有引用的对象。
- 一旦找到可回收的对象，垃圾回收器会调用其析构函数（如果存在），然后释放对象所占的内存。

##### **2.3.3 不确定的时间**

- 垃圾回收是非确定性的，无法准确预测对象何时会被销毁。这依赖于运行时的内存管理策略和系统的内存状况。

##### **2.3.4 手动触发垃圾回收**

- 虽然不推荐在正常情况下使用，但可以通过 `GC.Collect()` 手动触发垃圾回收。这将强制进行一次垃圾回收，但并不能保证立即回收所有可回收对象。

### 3. 示例代码

```csharp
class MyClass
{
    public MyClass()
    {
        Console.WriteLine("构造函数被调用");
    }

    ~MyClass()
    {
        Console.WriteLine("析构函数被调用");
    }
}

class Program
{
    static void Main(string[] args)
    {
        MyClass obj = new MyClass(); // 构造函数被调用
        obj = null; // 将引用设为 null，等待垃圾回收
    }
}
```

### 4. 目的

​	通常，析构函数用于释放非托管资源，如文件句柄、数据库连接等。由于这些资源不受 .NET 垃圾回收的管理，必须在析构函数中显式释放。

### 5. 性能考虑

​	使用析构函数会影响性能，因为它会使垃圾回收器需要更多的工作来跟踪和清理对象。因此，建议仅在确实需要清理非托管资源时使用析构函数。
